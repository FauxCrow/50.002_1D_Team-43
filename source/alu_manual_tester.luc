module alu_manual_tester#(
    CLK_FREQ ~ 1000 : CLK_FREQ > 0) 
(
    input clk,  // clock
    input rst,  // reset button
    input io_button[5],
    input io_dip[3][8],
    output led[8],
    output io_led[3][8],
    output io_segment[8],
    output io_select[4]
) {
    
    // instatiate ALU and alu auto tester rom
    alu alu
    alu_tester_rom rom
    
    // stores all hardcoded A, B, ALUFN, grouped by position, for each test case
    const A_VALUE = {c{31x{0}, 1}, 32x{0}}
    const B_VALUE = {32x{0}, 32x{0}}
    const ALUFN_VALUE = {b000000, b000000}  
    const TEST_CASES = 2
    
    sig pos
    sig current_test
    
    enum States {
        MANUAL,
        AUTO,
        CALCULATE
    }
    
    const CLK_FREQ = $is_sim() ? 1000 : 10000000 // put 1000 only for sim, 10M on hardware
    
    sig counter
    //sig slow_clock
    
    .clk(clk) {
        // The reset conditioner is used to synchronize the reset signal to the FPGA
        // clock. This ensures the entire FPGA comes out of reset at the same time.
        // reset_conditioner reset_cond
        
        edge_detector io_button_edge[5](#RISE(5x{{1}}), #FALL(5x{{0}}))
        button_conditioner io_button_cond[5](#CLK_FREQ(5x{{CLK_FREQ}})) 
        
        .rst(rst) {
            dff states[$width(States)](#INIT(States.MANUAL)) 
        }
    }
    
    always {
        pos = 0
        current_test = 0
        
        led = b00000000
        
        alu.a = 32x{0}
        alu.b = 32x{0}
        alu.alufn = b000000
        rom.alufn = b000000
        rom.pos = pos
        
        counter = 0 // default value of counter       
        
        // condition the buttons, then take rising edges only
        io_button_cond.in = io_button
        io_button_edge.in = io_button_cond.out
        
        
        // connect dffs
        states.d = states.q
        
        // STATES
        case (states.q){
            States.MANUAL:
                if (io_button_edge.out[1]){ // Middle Button Press
                    states.d = States.AUTO
                }
                else if (io_button_edge.out[2]){
                    // check current stage in manual
                }
                
            States.AUTO:
                alu.a = A_VALUE[current_test]
                alu.b = B_VALUE[current_test]
                alu.alufn = ALUFN_VALUE[current_test]
                rom.alufn = ALUFN_VALUE[current_test]
                
                // since each function has 4 test cases in the rom, we reset pos to 0 to not exceed this number
                if (pos > 4){
                    pos = 0
                }
                // set current rom value pos to confirmed pos
                rom.pos = pos
                
                // if the test case expected result is right, we turn on the first led blinker
                if (alu.out == rom.value){
                    led = 00000001
                }
                else{
                    led = 00000010
                }
                
                // move to next positions
                pos = pos + 1
                current_test = current_test + 1
                
                if (current_test == TEST_CASES){
                    states.d = States.MANUAL // Reverts back to default state once run
                }
                else{
                    states.d = States.AUTO // Move to the next test case, same state
                }

            /*
            States.STORE:
                // Every time the right button is pressed, it will store the bits into A & B until all bits have been stored
                if (io_button_edge.out[3]){
                    if (counter < 5){
                        counter = counter + 1
                        if (counter == 1){
                            alu.a[15:0] = c{io_dip[1][7:0], io_dip[0][7:0]}
                        }
                        if (counter == 2){
                            alu.a[31:16] = c{io_dip[1][7:0], io_dip[0][7:0]}
                        }
                        if (counter == 3){
                            alu.b[15:0] = c{io_dip[1][7:0], io_dip[0][7:0]}
                        }
                        if (counter == 4){
                            alu.b[15:0] = c{io_dip[1][7:0], io_dip[0][7:0]}
                        }
                    }
                    else {
                        counter = 0
                        states.d = States.MANUAL
                    }
                }
            */
            
            States.CALCULATE:
                // Assign bits to ALUFN
                alu.alufn = io_dip[2][5:0]
                
                // Produces a visible outputs on whether a test case passes or fails
                // How should we implement this?
                
                states.d = States.MANUAL // Revert back to MANUAL once finished
        }
        
        // OUTPUT HERE
        //led = b00000000
        io_led = 3x{{8h0}}
        io_segment = 0
        io_select = 4hF
    }
}